---
outline: deep
updateTime: "2023-10-13 23:07"
tags: "Vue/响应式"
desc: "《Vue.js设计与实现》第二篇“响应系统”的阅读记录"
---

这是笔者在阅读《Vue.js 设计与实现》第二篇“响应系统”过程中的心得体会。

## 响应系统概述

首先我们需要明确一个概念：什么是**响应式数据**？

回忆曾经编写过的 Vue 项目代码，我们或许可以给出这样一个定义：**当一个变量发生变化时，所有与之相关的地方也会随之变化**。我们来看这样一个例子：

```js
const obj = { text: "Hello world!" };
function effect() {
  document.body.innerHTML = obj.text;
}
```

在这段代码中，`effect` 函数会设置 `body` 的文本内容。但是，除了 `effect` 函数，其他任何函数也可以读取或设置 `body` 的文本内容。也就是说，`effect` 函数的执行可能会影响其他函数的执行，产生副作用。在这种情况下，我们称 `effect` 为一个**副作用函数**。

此时我们可以对响应式数据进行略微专业一点的定义：**当一个变量发生变化时，所有与该变量有关的副作用会自动重新执行**。对于上述代码，当我们运行 `obj.text = 'Hello javascript'` 时，我希望副作用函数 `effect` 会重新执行。

那么为了实现响应式系统，我们需要解决以下几个问题：

1. 哪些副作用函数与响应式数据有关？
2. 当响应式数据变化时，如何重新执行所有相关的副作用函数？

Vue 给出的解决方案是：通过 Proxy 拦截一个对象的**读取**与**设置**操作:

- 当副作用函数试图读取对象的某个属性时，我们会将该副作用函数存储在一个容器中。
- 当对象的某个属性被设置时，我们又会从容器中取出相关的副作用函数并重新执行它们。

然而，仅仅通过 Proxy 对数据进行劫持还是不够的，虽然 Proxy 可以告诉我们一个数据被访问或修改了，但它不能告诉我们这个操作是在哪个副作用函数中发生的，我们需要一个额外的工具来告诉 Proxy 这个数据到底被哪个副作用函数所依赖。这个工具我们姑且称之为 `effect`，它的作用是注册一个副作用函数。

分析至此，一个基本的响应系统，应该包含以下三个模块：

1. `track`: 当对象的读取操作触发时，进行副作用函数依赖收集。
2. `trigger`: 当对象的设置操作触发时，重新执行所有相关的副作用函数。
3. `effect`: 用于注册副作用函数，在 Proxy 拦截读取操作时，标记当前活跃的副作用函数。

## 实现基本的响应式

### 副作用函数的容器结构

在上文的叙述中，我们可以注意到无论是拦截读取还是设置操作，都需要用到一个存放副作用函数的“容器”。那么这个容器具体的数据结构是怎样的呢？回顾上文提到的代码：

```
function effect() {
  document.body.innerHTML = obj.text;
}
```

在这段代码中存在三个角色：

- 被操作（读取）的代理对象 obj
- 被操作（读取）的字段名 text
- 副作用函数 effect

根据上述信息，我们可以设计出这样的容器结构：`WeakMap<object,Map<key,Set<effectFn>>>`

它的含义是：

- `WeakMap`的键是被代理的对象，值是一个`Map`。使用`WeakMap`是为了防止内存泄漏，当对象不再被引用时，可以自动释放内存。
- `Map`的键是对象的字段名，值是一个`Set`。
- `Set`中存储的是与特定对象的特定字段相关联的所有副作用函数。

这样设计的目的是为了在对象的某个字段发生变化时，能够迅速找到所有相关的副作用函数并重新执行它们。具体的查找过程是：首先在`WeakMap`中根据对象找到对应的`Map`，然后在`Map`中根据字段名找到对应的`Set`，最后在`Set`中找到所有的副作用函数。

### 注册副作用函数

上文提到，我们需要一个额外的工具 `effect` 来跟踪哪个副作用函数正在访问哪个响应式数据，这个过程我们称之为“注册副作用函数”。事实上这个工具的实现非常简单，首先我们 `effect` 函数传入一个副作用函数，利用全局变量 `activeEffect` 将其标记为 “当前活跃的副作用函数”。然后，我们会执行传入的副作用函数，在这个副作用函数的执行过程中，每当访问到一个响应式数据，就会被 Proxy 所拦截，这时我们就可以将 `activeEffect` 加入到上文提到的容器之中。这样，我们就建立了副作用函数和响应式数据之间的联系。

一个简单的 `effect` 实现如下：（真正的 `effect` 函数需要考虑更多的情况）

```js
let activeEffect = null;
function effect(fn) {
  activeEffect = effectFn;
  fn();
}
```

### 依赖收集与触发更新

在 Vue 的响应系统中，依赖收集与触发更新是两个核心的步骤，虽然上文中已经提到过了，但不妨再过一遍整个流程。

首先我们通过 Proxy 拦截对象 `obj` 的读取与设置操作。

随后我们注册一个副作用函数，该副作用函数读取了 `obj.text`，在这个过程中，Proxy 对象会拦截这个**读取**操作，并且调用 `track` 函数。`track` 函数的作用是将当前活跃的副作用函数（由全局的 `activeEffect` 变量表示）添加到该属性的依赖列表中（借助前文提到的容器）。这样，我们就实现了对于 `obj.text` 的依赖收集

然后我们尝试修改 `obj.text` 的值， 在这个过程中，Proxy 对象会拦截这个**设置**操作，并且调用 `trigger` 函数。trigger 函数的作用是根据该对象与属性，在副作用函数的容器中找到所有依赖于该属性的副作用函数，并重新执行这些函数。这样，我们就实现了 `obj.text` 变化引发的更新。

一个简单的代理函数实现如下：

```js
function reactive(obj){
  return new Proxy(obj,{
    get(target,key){
      track(target,key); // 读取时收集依赖
      return target[key];
    }
    set(target,key,newVal){
      trigger(target,key); // 设置时触发更新
      target[key] = newVal;
      return true;
    }
  })
}
// 此时 person 就是一个响应式数据
const person = reactive({name: 'John', age:18});
```

## 拓展处理

### effect 存在的问题

在注册副作用函数时，我们还需要考虑两个问题。

1. 【嵌套副作用】

在一个副作用函数中又注册另一个副作用函数，就会导致 `activeEffect` 被覆盖，所以可以应当将 `activeEffect` 设置为**栈结构**。

2. 【分支切换】

在副作用函数中，可能存在这样的代码: `return flag?obj.foo:obj.bar` ，当 `flag` 不同时，应该与不同的响应式数据建立联系，同时也应当删除已建立的联系。解决方法其实很简单，在每次执行副作用函数之前，先把之间建立的所有依赖字段都删除了，然后在执行函数的过程中，又会对响应式数据进行读取，这就建立了新的依赖关系。

然后在之前进行依赖收集的时候，我们收集的是对象字段 => 副作用的联系，我们并不知道当前副作用函数依赖于哪些字段，所以在 `track` 时我们需要反向收集一下依赖以便调用前清除。

### 响应系统的可调度性

::: warning 🚧 - 暂时搁置

咕咕咕

:::

1. 延迟执行：新增 `lazy:Boolean` 属性。
2. 调度器：新增 `scheduler:Function` 属性，控制触发更新时副作用函数的执行时机。

借助 `lazy` 与 `scheduler` 我们还可以实现 `computed` 与 `watch`.

### 计算属性 computed

::: warning 🚧 - 暂时搁置

咕咕咕

:::

### 监听器 watch

::: warning 🚧 - 暂时搁置

咕咕咕

:::

### 对象 & 数组响应式

::: warning 🚧 - 暂时搁置

咕咕咕

:::

1. 索引与 length

- 通过索引可以修改或增加元素，当索引值大于数组长度时，就是增加元素
  假设当前对象为数组且为增加元素的操作，那么应该触发与 length 相关的副作用
- 通过 length 也会影响数组元素，当 length 设置为小于原来长度时
  相当于将 index > newLength 的数据设置为 undefined，需要触发相关的副作用

2. for...in 与 for...of 遍历

- 对于 for...in 我们使用 proxy 的 ownKeys 去拦截，普通对象我们是采用一个 symbol 去收集相关副作用，对于数组来说，for...in 与长度或者说元素的个数息息相关，所以我们可以直接使用 length 属性去收集相关副作用。
- 对于 for...of ，其本质上是去访问数组的内置属性 Symbol(Symbol.iterator). 事实上我们什么也不用做，就能实现目的。然而因为我们读取了 Symbol 类型的属性，追踪它们的副作用可能会产生意料之外的错误，所以我们需要在拦截读取的时候避免追踪 Symbol 类型的副作用。

3. 重写数组的查找方法: 以 includes 为例

当在数组中进行查找时，用户可能使用原始对象也可能使用代理对象，我们需要重写相关的方法额外处理。

4. 隐式改变数组长度的方法：push,pop,shift 等

当调用数组的 push 方法时，既会读取 length 属性又会设置 length 属性，这会导致两个独立的副作用函数互相影响。

### 原始值响应式方案 ref

`ref`在 Vue 中的主要目的是解决两个关键问题：代理原始值的问题和响应式丢失的问题。

1. **代理原始值的问题**

   在 JavaScript 中，`Proxy`无法直接代理原始值。为了解决这个问题，Vue 引入了`ref`。`ref`的实质是创建一个新的对象，将原始值包裹在这个对象中，然后将这个包裹对象传递给`reactive`。这样，原始值就可以间接地实现响应式。然而，这样做的结果是`ref`和普通对象在本质上没有什么区别，因此需要一个标志来区分`ref`和普通对象。

2. **响应式丢失的问题**

   响应式丢失是指当我们通过展开运算符从响应式对象创建一个普通对象时，如果响应式对象发生修改，创建的普通对象并不能收到这个修改，也不能触发相关的副作用。`toRef`和`toRefs`函数就是为了解决这个问题而设计的。`toRef`可以对响应式对象的某个属性进行包裹，返回一个包装后的对象。这个对象有一个访问器属性`value`，当读取`value`的值时，实际上是读取的响应式对象的值；当设置`value`的值时，实际上是在设置响应式对象的值。这样，我们就可以自由地使用展开运算符，而不会丢失响应能力。

然而，使用`ref`时，我们需要通过`.value`的形式去访问原始值，这对开发者来说是一种心智负担。为了解决这个问题，Vue 引入了`proxyRefs`函数。`proxyRefs`函数对传入的参数进行了代理，拦截读取和设置操作。如果传入的对象是`ref`类型，读取和设置操作就直接对`.value`进行。这样，开发者就可以无需访问`value`属性，就能读取`ref`的值。
