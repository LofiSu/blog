---
outline: deep
updateTime: "2023-09-22 20:54"
tags: "Vue/响应式"
desc: "《Vue.js设计与实现》第四章响应式系统的阅读记录"
---

## Vue 源码 - 响应式系统

这是笔者在阅读《Vue.js 设计与实现》第二篇“响应系统”过程中的心得体会。

那么首先我们需要明确一个概念，什么是**响应式数据**？

回忆曾经编写过的 Vue 项目代码，我们或许可以给出这样一个定义：**当一个变量发生变化时，所有与之相关的地方也会随之变化**。我们来看这样一个例子：

```js
const obj = { text: "Hello world!" };
function effect() {
  document.body.innerHTML = obj.text;
}
```

在上述代码中，当 `effect` 函数执行时，它会设置 `body` 的文本内容，但除了 `effect` 函数之外，其他的任何函数都可以读取或设置 `body` 的文本内容。也就是说 `effect` 函数的执行直接或间接地影响了其他函数的执行，造成了副作用，这时我们称 `effect` 为一个**副作用函数**。

此时我们可以对响应式数据进行略微专业一点的定义：**当一个变量发生变化时，所有与该变量有关的副作用会自动重新执行**。针对上述代码，当我运行 `obj.text = 'Hello javascript'` 时，我希望副作用函数 `effect` 会重新执行。

那么为了实现响应式系统，我们要解决以下几个问题：

1. 与响应式数据相关的副作用函数有哪些？
2. 当响应式数据变化时如何重新执行所有相关的副作用函数？

Vue 给出的解决方案是：通过 proxy 拦截一个对象的**读取**与**设置**操作:

- 当副作用函数试图读取对象的某个属性时，我们会将其存储到一个“桶”中。
- 当对象某个属性被设置时，我们又会将副作用函数从“桶”中取出重新执行。

然而，仅仅通过 proxy 对数据进行劫持还是不够的，它可以告诉我们一个数据被访问或修改了，但它不能告诉我们这个操作是在哪个副作用函数中发生的，我们需要一个额外的工具来告诉 proxy 这个数据到底被哪个副作用函数所依赖。这个工具我们姑且称之为 `effect`，它的作用是注册一个副作用函数。

在笔者看来，一个基本的响应系统，由三个模块组成：

1. `effect`:用于注册副作用函数
2. `track`:当 get 操作触发时进行依赖收集
3. `trigger`:当 set 操作触发时通知视图更新

在`effect`模块中，主要作用是实现了对全局变量 `activeEffect` 的更新，以便后续依赖收集时使用，同时为了解决【分支切换】导致的依赖残留问题，还引入了`cleanup` 函数进行依赖关系的清理。

在`track`模块中，利用`WeakMap/Map/Set`进行副作用函数的依赖收集。

在`trigger`模块中，取出副作用函数并执行，需要注意的是为了防止`obj.text++`这种同时触发 set 和 get 会导致无限循环，还要判断取出的副作用函数是否与`activeEffect`相同.
