---
updateTime: "2024-09-08 00:48"
desc: "前端面试高频手写题与场景题, 目前收录防抖、Promise.all、并发请求控制..."
tags: "八股"
outline: 3
---

## 手写题

### 实现 Promise.all

**🎯 题目描述**

Promise.all() 静态方法接受一个 Promise 可迭代对象作为输入，并返回一个 Promise。

- 当所有输入的 Promise 都被兑现时，返回的 Promise 也将被兑现（即使传入的是一个空的可迭代对象），并返回一个包含所有兑现值的数组。
- 如果输入的任何 Promise 被拒绝，则返回的 Promise 将被拒绝，并带有第一个被拒绝的原因。

**📚 示例代码**

```js
const promiseAll = (proms) => {
  return new Promise((resolve, reject) => {
    if (proms == null || typeof proms[Symbol.iterator] !== "function") {
      throw new TypeError("proms must be an iterable");
    }
    proms = [...proms];

    if (proms.length === 0) resolve([]);
    let count = 0;
    const result = [];
    proms.forEach((prom, index) => {
      Promise.resolve(prom)
        .then((res) => {
          result[index] = res;
          if (++count === proms.length) resolve(result);
        })
        .catch(reject);
    });
  });
};
```

### 防抖

**🎯 题目描述**

实现一个防抖函数：在一定时间内某个事件频繁触发时，回调函数只执行一次。

- 函数接收两个参数：第一个参数是回调函数，第二个参数是等待时间。
- 返回一个新函数，新函数在等待时间内被多次调用时，只执行一次。

**📚 示例代码**

需要注意的细节：
- **`setTimeout` 回调函数执行时, `this` 指向 `window`**，需要记录原函数的 `this`。
- 为了支持回调函数的参数传递，使用 `...args` 获取参数并利用 `apply` 传递参数。

::: code-group

```js
const debounce = (fn, wait) => {
  let timer;
  return function (...args) {
    let context = this;
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(context, args);
    }, wait);
  };
};
```

```ts
function debounce<T extends (...args: any[]) => void>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: ReturnType<typeof setTimeout> | undefined;

  return function (this: ThisParameterType<T>, ...args: Parameters<T>): void {
    let context = this;
    clearTimeout(timeout!);
    timeout = setTimeout(() => {
      func.apply(this, args);
    }, wait);
  };
}
```

```html [具体应用场景]
<body>
  <button onclick="handleClick()">Click</button>
</body>

<script>
  const debounce = (fn, wait) => {
    let timer;
    return function (...args) {
      let context = this;
      clearTimeout(timer);
      timer = setTimeout(() => {
        fn.apply(this, args);
      }, wait);
    };
  };
  /*
  应用场景举例：
    1. 某些查询数据的按钮多次点击时，只发送一次请求
    2. scroll / input / resize 等事件频繁触发时，减少回调函数的执行次数
  */
  const handleClick = debounce(() => {
    console.log("click");
  }, 1000);
</script>
```

:::

**升级版：支持立即执行**

::: warning 🚧 TODO... 

:::

## 场景题

### 并发请求控制

实现一个 `PromisePool` 类，限制并发请求的数量。

```js
class PromisePool {
  constructor(capacity) {
    this.capacity = capacity;
    this.tasks = [];
    this.running = 0;
  }

  add(fn) {
    return new Promise((resolve, reject) => {
      this.tasks.push({
        fn,
        resolve,
        reject,
      });
      this._run();
    });
  }

  _run() {
    while (this.tasks.length && this.running < this.capacity) {
      const { fn, resolve, reject } = this.tasks.shift();
      this.running++;
      fn()
        .then(resolve, reject)
        .finally(() => {
          this.running--;
          this._run();
        });
    }
  }
}

const sleep = (time) => new Promise((resolve) => setTimeout(resolve, time));
const addTask = (time, str) => {
  pool
    .add(() => sleep(time))
    .then(() => {
      console.log(str);
    });
};
const pool = new PromisePool(2);
addTask(10000, "1");
addTask(5000, "2");
addTask(3000, "3");
addTask(4000, "4");
addTask(5000, "5");
// 2 3 1 4 5
```
