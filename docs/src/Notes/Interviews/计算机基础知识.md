---
updateTime: "2023-12-13 23:29"
desc: "面试官：浏览器从输入URL到页面展示的过程是怎样的？浏览器的缓存机制是怎样的？什么是同源策略又有哪些跨域解决方案？你还是支支吾吾一头雾水吗？看完这篇文章，下次面试直接开始吟唱！😎"
tags: "八股/计算机基础"
outline: 2
---

:::warning TODO 内容待整理

:::

现在我来描述一下浏览器的发送请求时的过程。我将从浏览器缓存，CORS 策略几个方面展开讲解。

首先，我们来看一下浏览器的缓存。在我们发送请求之前，浏览器会先检查请求的 URL 是否在缓存列表之中，如果在的话浏览器将检查缓存是否过期，如果没有过期的话，浏览器将直接从缓存中读取数据，如果过期的话，浏览器将向服务器发送请求。

那么如何检查缓存是否过期呢？这里涉及到浏览器的缓存机制，包括强制缓存与协商缓存。强制缓存提供了一个在客户端初步判断缓存是否过期的方法，而协商缓存则是提供了一个在服务端精确判断缓存是否过期的方法。

具体来说，当浏览器第一次向服务器请求资源时，服务器会在响应头中包含缓存策略，例如 `cache-control` 或者 `Expires`，这些缓存策略会告诉浏览器如何处理缓存。对于 `Expires` 而言，它的含义是服务器的绝对时间，存在的问题是服务器与客户端的时间可能不一致。为了解决这个问题，`cache-control` 出现了，这个字段中存在一个 `max-age`，它的含义是资源在客户端的最大存活时间，是一个相对时间，单位是秒（如果有的资源在一秒内被更新就可能检测不到）。当浏览器再次请求这个资源时，如果 `max-age` 没有过期的话，浏览器将直接从缓存中读取数据。

当浏览器发现缓存过期时，就需要在请求头中携带上某些字段，服务器会根据这些字段判断客户端本地的缓存是否能够正常使用。这些字段包括：`Last-Modified` & `If-Modified-Since` 和 `ETag` & `If-None-Match`. 浏览器在响应头中会返回 `Last-Modified` 和 `ETag`，分别表示资源最后修改时间和资源的唯一标识。浏览器会将其缓存起来，当强制缓存为命中时，就会从缓存中取出这两个字段，例如取出 `ETag`，然后将其对应的值放到请求头的 `If-None-Match` 字段中，然后发送请求。服务器接收到请求后，会将 `If-None-Match` 的值与服务器中的 `ETag` 进行比对，如果相同的话，说明资源没有更新，返回 `304`，浏览器接收到 `304` 后，就会从缓存中读取数据。否则则返回 `200` 和新的资源以及新的缓存策略。

当然并不是所有资源都应该被缓存，对于一些需要频繁更新或者实时请求的资源，例如新闻，股票价格等等，就不应该被缓存。对于这些资源，我们可以在 `cache-control` 中设置 `no-cache` 或者 `no-store`，前者表示需要哪怕强制缓存没有过期也需要经过协商缓存才能使用，后者表示不需要经过任何缓存。

接下来我们来看浏览器的同源策略，同源策略是浏览器的一种安全策略，它用于限制一个源的文档或者脚本如何能够与另一个源的资源进行交互。如果两个 URL 的协议，端口（如果有指定的话）和域名都相同的话，则这两个 URL 是同源。通常我们会采用同源策略来抵挡 CSRF 攻击。那么什么是 CSRF 攻击呢，举一个简单的例子，现在你登录了 bank.com 这个网站，网站中记录了你的 cookie 信息，然后你又打开了一个标签页，在这个标签页中，你访问了一个恶意网站 evil.com，这个网站中存在一些恶意脚本，当你点击某个按钮时，这些脚本就会向 bank.com 发送请求，这时候浏览器会携带上 bank.com 的 cookie 信息，这样恶意网站就可以利用这些信息进行一些恶意操作，例如转账等等。而同源策略就是为了防止这种情况的发生，它会阻止恶意网站获取 bank.com 的响应数据。（但并不能完全解决 CSRF 问题，更好的方案是使用 cookie 的 sameSite 字段以及服务器动态生成 CSRF Token）

当然并不是所有的跨域请求都是恶意的，有时候我们需要从其他网站请求一些数据，例如请求一些第三方的 API，这时候我们就需要去解决跨域的问题。最为正统的方法是 CORS 策略，让服务器在响应头中设置 `Access-Control-Allow-Origin`... 的一些字段，这样浏览器就会知道这个请求是可以被允许的。当然还有一些其他的方法，由于同源策略是浏览器环境下的，在 Node.js 发送请求则不存在这些限制，我们可以接著一个代理服务器来实现对于跨域请求的处理。如果你使用 Webpack 或者 Vite 你可以通过配置代理来解决跨域问题，如果你使用 Node.js 的话，你可以使用 `http-proxy-middleware` 这个库来解决跨域问题。

同时呢，在 CORS 策略中请求又可以分类简单请求与复杂请求，简单请求通常是指那些可以由 HTML 本身发起的，例如简单的 GET，POST，而复杂请求是指需要通过 JavaScript 脚本才能发起的请求，例如修改请求头的 `Content-Type`，或者使用 `PUT`，`DELETE` 等等。对于简单请求，浏览器会在请求头中添加一个 `Origin` 字段，表示请求的源，服务器可以根据这个字段来判断是否允许这个请求。对于复杂请求，浏览器会先发送一个预检请求，这个请求是一个 `OPTIONS` 请求，这个请求中会携带 `Request-Headers` 等字段，表示实际请求的请求头与请求方法等等，服务器根据这些字段是否允许这个请求，它会在响应头中添加 `Access-Control-Allow-Headers` 等字段，浏览器通过这些字段来判断是否允许这个请求。如果允许则浏览器会发送实际的请求，否则会返回一个错误。

## 输入 URL 到页面展示的过程 🎨

用户在地址栏中输入一个 URL 之后，将会发生以下几个过程：

DNS 解析 -> TCP 握手 -> TLS 握手 -> 请求与响应 -> 解析 -> 渲染

### 1. 导航

在网络的传输过程中，起点与终点是使用 IP 地址来标识的，而 IP 地址是比较难记忆的，所以才有了域名的出现。用户输入的 URL 通常是一个域名而非 IP，那么要做的第一件事情就是将域名解析成 IP 地址。这个过程被称之为 **DNS 解析**📚，其具体的过程是这样的：浏览器首先查看自己的缓存中是否有这个域名对应的 IP 地址，如果有的话则直接使用，如果没有则去查看本地 host 文件，如果还是没有的话则去请求 DNS 服务器，DNS 服务器会返回一个 IP 地址，然后浏览器就可以使用这个 IP 地址来发送请求了。

### 2. TCP 握手

获得了服务器的 IP 地址之后，浏览器就会通过 TCP 三次握手与服务器建立连接。

- 【你好，可以听到我讲话吗】浏览器发送 `SYN` 与序列号 `seq=x` 给服务器
- 【可以的，你可以听到我讲话吗】服务器收到了发送 `ACK=x+1 / SYN / seq=y` 给浏览器
- 【可以听到】浏览器再发送一个 `ACK=y+1` 包给服务器

> 为什么需要三次握手呢？🙌
>
> 三次握手都能够确保通信双方能够接收到对方数据并做出响应（很好的理解方式就是上面的对话。 如果只有两次握手，服务器端并不能知道浏览器是否收到了自己的数据）

### 3. TLS 握手

对于使用 https 协议的网站，浏览器还需要与服务器进行 TLS 握手。

- 浏览器发送 ClientHello 并告知服务器自己支持的加密套件、TLS 版本与随机数 A
- 服务端发送 ServerHello 并告知浏览器自己选择的加密套件、TLS 版本与随机数 B 同时附带自己的 CA 证书
- 浏览器验证 CA 证书的有效性：证书是否由可信机构颁发、证书中的域名是否与请求的域名一致、证书是否过期。随后生成一个随机数作为预主密钥并使用服务端的公钥加密这个随机数，发送给服务端。
- 服务端使用自己的私钥解密浏览器发送的预主密钥，并结合随机数 A/B 生成会话密钥 🔒。

在随后的数据传输过程中，浏览器与服务器使用会话密钥进行**对称加密**。

### 4. 请求与响应

成功建立连接之后，浏览器将会发送一个初始的 HTTP GET 请求，获得一个 HTML 文件。浏览器收到响应之后会解析 HTML 文件，如果 HTML 文件中包含了其他资源的引用（例如图片、样式表、脚本等），那么浏览器会再次发送请求获取这些资源。

### 5. 解析

浏览器首先会处理 HTML 标记并构造 DOM 树，当解析器发现非阻塞资源，例如图片或者 CSS 文件，浏览器会请求这些资源并且继续解析，但是对于没有 `async/defer` 属性的 `script` 标签会暂时停止对 HTML 的解析，知道脚本被下载并执行完毕。

- `async`: 异步下载，下载完成后立即执行
- `defer`: 异步下载，等到 HTML 解析完成后再执行

为了优化解析 DOM 的过程，通常会有**预加载解析器**📝 的参与。它在构建 DOM 树的同时运行，用来扫描 HTML 文档，寻找可能需要加载的资源（例如图片、样式表、脚本、字体文件等）。当预加载解析器发现了这些资源之后，它会指示浏览器开始加载这些资源，即使它们还没有被解析器处理到。这样可以减少页面的加载时间，因为一些资源的下载和 DOM 的解析可以并行进行。

接下来浏览器将会处理 CSS 并构建 CSSOM 树。等待与处理 CSS 的过程并不会阻塞 DOM 的解析，但是会阻塞 JavaScript 的执行。因为 JavaScript 经常用于查询元素的样式。

### 6. 渲染

浏览器在构建 DOM 树和 CSSOM 树之后，就会开始构建渲染树。渲染树是由 DOM 树与 CSSOM 树合并而成的，它只包含了需要显示的节点以及这些节点的样式信息。渲染树构建完成之后，浏览器就可以开始布局（layout）与绘制（paint）。

- 布局：确定每个节点在屏幕上的确切位置
- 绘制：将元素的每个可视部分绘制到屏幕上，包括文本、颜色、边框、阴影等 🌈。
