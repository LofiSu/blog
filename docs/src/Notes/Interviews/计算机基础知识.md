---
updateTime: "2023-12-13 23:29"
desc: "面试官：浏览器从输入URL到页面展示的过程是怎样的？浏览器的缓存机制是怎样的？什么是同源策略又有哪些跨域解决方案？你还是支支吾吾一头雾水吗？看完这篇文章，下次面试直接开始吟唱！😎"
tags: "八股/计算机基础"
outline: deep
---

:::warning TODO 内容待整理

:::

现在我来描述一下浏览器的发送请求时的过程。我将从浏览器缓存，CORS 策略几个方面展开讲解。

首先，我们来看一下浏览器的缓存。在我们发送请求之前，浏览器会先检查请求的 URL 是否在缓存列表之中，如果在的话浏览器将检查缓存是否过期，如果没有过期的话，浏览器将直接从缓存中读取数据，如果过期的话，浏览器将向服务器发送请求。

那么如何检查缓存是否过期呢？这里涉及到浏览器的缓存机制，包括强制缓存与协商缓存。强制缓存提供了一个在客户端初步判断缓存是否过期的方法，而协商缓存则是提供了一个在服务端精确判断缓存是否过期的方法。

具体来说，当浏览器第一次向服务器请求资源时，服务器会在响应头中包含缓存策略，例如 `cache-control` 或者 `Expires`，这些缓存策略会告诉浏览器如何处理缓存。对于 `Expires` 而言，它的含义是服务器的绝对时间，存在的问题是服务器与客户端的时间可能不一致。为了解决这个问题，`cache-control` 出现了，这个字段中存在一个 `max-age`，它的含义是资源在客户端的最大存活时间，是一个相对时间，单位是秒（如果有的资源在一秒内被更新就可能检测不到）。当浏览器再次请求这个资源时，如果 `max-age` 没有过期的话，浏览器将直接从缓存中读取数据。

当浏览器发现缓存过期时，就需要在请求头中携带上某些字段，服务器会根据这些字段判断客户端本地的缓存是否能够正常使用。这些字段包括：`Last-Modified` & `If-Modified-Since` 和 `ETag` & `If-None-Match`. 浏览器在响应头中会返回 `Last-Modified` 和 `ETag`，分别表示资源最后修改时间和资源的唯一标识。浏览器会将其缓存起来，当强制缓存为命中时，就会从缓存中取出这两个字段，例如取出 `ETag`，然后将其对应的值放到请求头的 `If-None-Match` 字段中，然后发送请求。服务器接收到请求后，会将 `If-None-Match` 的值与服务器中的 `ETag` 进行比对，如果相同的话，说明资源没有更新，返回 `304`，浏览器接收到 `304` 后，就会从缓存中读取数据。否则则返回 `200` 和新的资源以及新的缓存策略。

当然并不是所有资源都应该被缓存，对于一些需要频繁更新或者实时请求的资源，例如新闻，股票价格等等，就不应该被缓存。对于这些资源，我们可以在 `cache-control` 中设置 `no-cache` 或者 `no-store`，前者表示需要哪怕强制缓存没有过期也需要经过协商缓存才能使用，后者表示不需要经过任何缓存。

接下来我们来看浏览器的同源策略，同源策略是浏览器的一种安全策略，它用于限制一个源的文档或者脚本如何能够与另一个源的资源进行交互。如果两个 URL 的协议，端口（如果有指定的话）和域名都相同的话，则这两个 URL 是同源。通常我们会采用同源策略来抵挡 CSRF 攻击。那么什么是 CSRF 攻击呢，举一个简单的例子，现在你登录了 bank.com 这个网站，网站中记录了你的 cookie 信息，然后你又打开了一个标签页，在这个标签页中，你访问了一个恶意网站 evil.com，这个网站中存在一些恶意脚本，当你点击某个按钮时，这些脚本就会向 bank.com 发送请求，这时候浏览器会携带上 bank.com 的 cookie 信息，这样恶意网站就可以利用这些信息进行一些恶意操作，例如转账等等。而同源策略就是为了防止这种情况的发生，它会阻止恶意网站获取 bank.com 的响应数据。（但并不能完全解决 CSRF 问题，更好的方案是使用 cookie 的 sameSite 字段以及服务器动态生成 CSRF Token）

当然并不是所有的跨域请求都是恶意的，有时候我们需要从其他网站请求一些数据，例如请求一些第三方的 API，这时候我们就需要去解决跨域的问题。最为正统的方法是 CORS 策略，让服务器在响应头中设置 `Access-Control-Allow-Origin`... 的一些字段，这样浏览器就会知道这个请求是可以被允许的。当然还有一些其他的方法，由于同源策略是浏览器环境下的，在 Node.js 发送请求则不存在这些限制，我们可以接著一个代理服务器来实现对于跨域请求的处理。如果你使用 Webpack 或者 Vite 你可以通过配置代理来解决跨域问题，如果你使用 Node.js 的话，你可以使用 `http-proxy-middleware` 这个库来解决跨域问题。

同时呢，在 CORS 策略中请求又可以分类简单请求与复杂请求，简单请求通常是指那些可以由 HTML 本身发起的，例如简单的 GET，POST，而复杂请求是指需要通过 JavaScript 脚本才能发起的请求，例如修改请求头的 `Content-Type`，或者使用 `PUT`，`DELETE` 等等。对于简单请求，浏览器会在请求头中添加一个 `Origin` 字段，表示请求的源，服务器可以根据这个字段来判断是否允许这个请求。对于复杂请求，浏览器会先发送一个预检请求，这个请求是一个 `OPTIONS` 请求，这个请求中会携带 `Request-Headers` 等字段，表示实际请求的请求头与请求方法等等，服务器根据这些字段是否允许这个请求，它会在响应头中添加 `Access-Control-Allow-Headers` 等字段，浏览器通过这些字段来判断是否允许这个请求。如果允许则浏览器会发送实际的请求，否则会返回一个错误。
