---
updateTime: "2024-03-13 01:38"
desc: "面试官：浏览器从输入URL到页面展示的过程是怎样的？浏览器的缓存机制是怎样的？什么是同源策略又有哪些跨域解决方案？你还是支支吾吾一头雾水吗？看完这篇文章，下次面试直接开始吟唱！😎"
tags: "八股/计算机基础"
outline: 2
---

## 浏览器缓存策略 ⚔️

浏览器的缓存机制主要分为**强制缓存**与**协商缓存**。强制缓存通常是在浏览器端判断是否使用缓存，而协商缓存则是在服务器端判断是否使用缓存。

两者是共同工作的，在使用缓存之前，浏览器会**先判断强制缓存是否生效**🎯，如果强制缓存失效，浏览器会发送请求到服务器，**再通过协商缓存来判断是否使用缓存**🧐。

### 强制缓存

强制缓存可以通过响应头中的 `Expires` 和 `Cache-Control` 来设置。当浏览器第一次请求资源时，服务器会在响应头中包含相应的缓存策略（就是这俩字段），浏览器会将其记录下来，当再次请求这个资源时，浏览器会根据这些字段来判断是否使用缓存。

> 当 `Expires` 和 `Cache-Control` 同时存在时，`Cache-Control` 优先级高于 `Expires`。

**Expires**：这是一个由服务器端所决定的绝对时间，表示资源的过期时间，以秒为单位。

```yaml
Expires: Thu, 10 Nov 2017 08:45:11 GMT
```

- 由于是绝对时间，考虑到时差/误差或者客户端自行修改等因素，都会造成客户端与服务器端时间不一致，从而导致缓存失效。
- 字段表示过于复杂 👾，很容易因为非法属性值从而设置失效。

**Cache-Control**：相对时间

```yaml
Cache-control: max-age=2592000 no-cache
```

- 到期：`max-age` 代表最大有效时间，是一个相对时间，单位是秒。
- 可缓存性
  - `public`：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)
  - `private`：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。
  - `no-cache`：不进行强制缓存的过期判断，而是直接使用协商缓存交由服务器判断。
  - `no-store`: 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。
- 重新验证：`must-revalidate` 一旦资源过期，在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。

### 协商缓存

当浏览器在第一次请求资源时，服务器不仅会在响应头中包含强制缓存的策略，还会标明与协商缓存有关的信息，例如：

- `Last-Modified` （对应请求头中的 `If-Modified-Since`）
- `ETag` （对应请求头中的 `If-None-Match`）

他们的执行流程大概如下（以`ETag`为例）：

当首次请求资源时，服务器会在响应头中加入 `ETag` 字段，浏览器会将这个字段记录下来。再次请求资源时，浏览器会在**请求头中加入 `If-None-Match` 字段，值为上次记录的 `ETag` 字段的值**。

服务器会将这两个值进行对比，如果相等，则表示未修改，响应 <HText type='true'> 304 Not Modified </HText>；反之，则表示修改了，响应 `200 OK`，并返回最新的数据与缓存标识。

而这两组字段的**区别**在于：

- `Last-Modified` 是一个 GMT 格式的时间字符串，以秒为单位，表示资源的最后修改时间。如果资源在 1s 内被修改 🚀，那么这个字段就会失效。同时，如果文件是通过服务器**动态生成**🌊 的，那么该方法的更新时间永远是生成的时间，尽管文件可能并没有改变，但仍然会被认为改变了。
- `ETag` 是一个由服务器通过某些算法生成的字符串，只要资源有变化，这个值就会发生变化，因此可以更加**精确**🎉 的判断资源是否有变化。

## 跨域资源共享

跨域问题的产生源自**浏览器的同源策略 🍨**，同源策略是浏览器的一种安全策略，能够帮助隔离恶意文档，减少可能被攻击的媒介，主要用于防止一些常见的网络攻击（例如 CSRF 攻击）

同源策略指的是：如果两个 URL 的**协议**，**端口**（如果有指定的话）和**域名**都相同的话，则这两个 URL 是同源。只有同源的文档才能够自由地进行交互，否则就会受到限制。

### 解决跨域问题的方案

1. **CORS 跨域资源共享**（最为正统的解决方案 🏆）： 是现代浏览器普遍支持的一种机制，允许服务器明确指示哪些其他源（domain、协议、端口）有权访问它的资源。服务器可以在响应头中添加特定的字段，例如`Access-Control-Allow-Origin / Access-Control-Allow-Methods` 等等，来告诉浏览器这个请求是可以被允许的。

2. **代理**：需要注意的是，跨域问题是浏览器的限制，所以在 Node 环境中并不存在跨域问题，我们可以通过搭建一个 NodeJS 代理服务器来实现对于跨域请求的处理。具体而言，如果你使用 Webpack 或者 Vite 你可以通过配置相应的插件来解决跨域问题，如果你使用 Node.js 的话，你可以使用 `http-proxy-middleware` 这个库来解决跨域问题。需要注意的是，这个办法**只适用于开发环境** 🚧。

3. **Nginx 反向代理**💡：客户端向 Nginx 服务器发送请求，Nginx 服务器再将请求转发到真正的目标服务器，然后将目标服务器的响应返回给客户端。在这个过程中，我们需要配置 Nginx 服务器的反向代理规则，来对目标服务器的相应做进一步处理，例如修改响应头使其支持跨域请求。

### 简单请求与复杂请求

在 CORS 策略中请求可以分类简单请求与复杂请求。

- **简单请求**通常是指那些可以直接由 HTML 发起的请求，例如使用 GET 或 POST 方法的请求。这类请求的特点是它们不会改变服务端的状态，并且只使用了一些安全的头信息集合。对于简单请求，浏览器会在请求头中添加一个 Origin 字段来表示请求的源。服务器可以根据这个字段来判断是否允许该请求。
- **复杂请求**🎨 通常指的是那些需要通过 JavaScript 脚本发起，并且可能会改变服务端状态或使用了不属于简单请求头集合的请求，例如修改请求头中的 `Content-Type`，或者使用 PUT、DELETE 等 HTTP 方法。

对于复杂请求，浏览器会首先发送一个预检（preflight）请求，这通常是一个 <HText type="true">OPTIONS</HText> 方法的请求。预检请求中会包含 `Access-Control-Request-Headers / Methods` 等字段，用以表示实际请求中将会使用的 HTTP 方法和头信息等。服务器会根据这些信息来决定是否允许实际的请求。如果服务器允许，它会在响应头中添加 `Access-Control-Allow-Headers` 和其他相关字段。浏览器将根据这些响应头来决定是否继续发送实际的请求。如果不允许，浏览器将返回一个错误 ⚡。

## CSRF 攻击 🚧

那么什么是 CSRF 攻击呢，举一个简单的例子，现在你登录了 bank.com 这个网站，网站中记录了你的 cookie 信息，然后你又打开了一个标签页，在这个标签页中，你访问了一个恶意网站 evil.com，这个网站中存在一些恶意脚本，当你点击某个按钮时，这些脚本就会向 bank.com 发送请求，这时候浏览器会携带上 bank.com 的 cookie 信息，这样恶意网站就可以利用这些信息进行一些恶意操作，例如转账等等。而同源策略就是为了防止这种情况的发生，它会阻止恶意网站获取 bank.com 的响应数据。（但并不能完全解决 CSRF 问题，更好的方案是使用 cookie 的 sameSite 字段以及服务器动态生成 CSRF Token）

## 输入 URL 到页面展示的过程 🎨

用户在地址栏中输入一个 URL 之后，将会发生以下几个过程：

DNS 解析 -> TCP 握手 -> TLS 握手 -> 请求与响应 -> 解析 -> 渲染

### 1. 导航

在网络的传输过程中，起点与终点是使用 IP 地址来标识的，而 IP 地址是比较难记忆的，所以才有了域名的出现。用户输入的 URL 通常是一个域名而非 IP，那么要做的第一件事情就是将域名解析成 IP 地址。这个过程被称之为 **DNS 解析**📚，其具体的过程是这样的：浏览器首先查看自己的缓存中是否有这个域名对应的 IP 地址，如果有的话则直接使用，如果没有则去查看本地 host 文件，如果还是没有的话则去请求 DNS 服务器，DNS 服务器会返回一个 IP 地址，然后浏览器就可以使用这个 IP 地址来发送请求了。

### 2. TCP 握手

获得了服务器的 IP 地址之后，浏览器就会通过 TCP 三次握手与服务器建立连接。

- 【你好，可以听到我讲话吗】浏览器发送 `SYN` 与序列号 `seq=x` 给服务器
- 【可以的，你可以听到我讲话吗】服务器收到了发送 `ACK=x+1 / SYN / seq=y` 给浏览器
- 【可以听到】浏览器再发送一个 `ACK=y+1` 包给服务器

> 为什么需要三次握手呢？🙌
>
> 三次握手都能够确保通信双方能够接收到对方数据并做出响应（很好的理解方式就是上面的对话。 如果只有两次握手，服务器端并不能知道浏览器是否收到了自己的数据）

### 3. TLS 握手

对于使用 https 协议的网站，浏览器还需要与服务器进行 TLS 握手。

- 浏览器发送 ClientHello 并告知服务器自己支持的加密套件、TLS 版本与随机数 A
- 服务端发送 ServerHello 并告知浏览器自己选择的加密套件、TLS 版本与随机数 B 同时附带自己的 CA 证书
- 浏览器验证 CA 证书的有效性：证书是否由可信机构颁发、证书中的域名是否与请求的域名一致、证书是否过期。随后生成一个随机数作为预主密钥并使用服务端的公钥加密这个随机数，发送给服务端。
- 服务端使用自己的私钥解密浏览器发送的预主密钥，并结合随机数 A/B 生成会话密钥 🔒。

在随后的数据传输过程中，浏览器与服务器使用会话密钥进行**对称加密**。

### 4. 请求与响应

成功建立连接之后，浏览器将会发送一个初始的 HTTP GET 请求，获得一个 HTML 文件。浏览器收到响应之后会解析 HTML 文件，如果 HTML 文件中包含了其他资源的引用（例如图片、样式表、脚本等），那么浏览器会再次发送请求获取这些资源。

### 5. 解析

浏览器首先会处理 HTML 标记并构造 DOM 树，当解析器发现非阻塞资源，例如图片或者 CSS 文件，浏览器会请求这些资源并且继续解析，但是对于没有 `async/defer` 属性的 `script` 标签会暂时停止对 HTML 的解析，知道脚本被下载并执行完毕。

- `async`: 异步下载，下载完成后立即执行
- `defer`: 异步下载，等到 HTML 解析完成后再执行

为了优化解析 DOM 的过程，通常会有**预加载解析器**📝 的参与。它在构建 DOM 树的同时运行，用来扫描 HTML 文档，寻找可能需要加载的资源（例如图片、样式表、脚本、字体文件等）。当预加载解析器发现了这些资源之后，它会指示浏览器开始加载这些资源，即使它们还没有被解析器处理到。这样可以减少页面的加载时间，因为一些资源的下载和 DOM 的解析可以并行进行。

接下来浏览器将会处理 CSS 并构建 CSSOM 树。等待与处理 CSS 的过程并不会阻塞 DOM 的解析，但是会阻塞 JavaScript 的执行。因为 JavaScript 经常用于查询元素的样式。

### 6. 渲染

浏览器在构建 DOM 树和 CSSOM 树之后，就会开始构建渲染树。渲染树是由 DOM 树与 CSSOM 树合并而成的，它只包含了需要显示的节点以及这些节点的样式信息。渲染树构建完成之后，浏览器就可以开始布局（layout）与绘制（paint）。

- 布局：确定每个节点在屏幕上的确切位置
- 绘制：将元素的每个可视部分绘制到屏幕上，包括文本、颜色、边框、阴影等 🌈。
