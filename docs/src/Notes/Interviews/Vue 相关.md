---
updateTime: "2023-11-21 23:53"
desc: "Vue 八股文の个人理解"
tags: "八股/Vue"
outline: deep
---

## Vue3 生命周期

![](https://cn.vuejs.org/assets/lifecycle_zh-CN.FtDDVyNA.png)

## V-if 与 V-show 的区别

- `v-if` 是真正的条件渲染，当条件值为 false 时，组件不会被渲染，即不会在 DOM 中存在。它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建，这意味着如果切换带有输入框的表单，你将会丢失所有的已输入内容。
- `v-show` 则是简单的 CSS 属性切换，当条件值为 false 时，组件也会被渲染，只是 CSS 的 display 属性会被设置为 none。

总的来说，`v-if` 具有更高的切换开销，而 `v-show` 具有更高的初始渲染开销。如果需要频繁切换，更推荐使用 `v-show`；如果在运行时条件很少改变，则推荐使用 `v-if`。

## SPA 和 SSR 的区别

**SPA**: 单页面应用，在首次请求时，服务端会返回一个 HTML 文件，其中只包含了一个根节点，也就是我们 Vue 应用的挂载点。随后，浏览器会根据这个 HTML 文件去请求 js、css 等静态资源，这些资源会被浏览器缓存起来，当我们跳转到其他页面时，浏览器不会再次向服务端发起请求，而是直接从缓存中读取资源，然后根据路由去渲染页面。这个过程通常需要借助 `window.history` 对象或者 `location.hash` 来实现。

- 优点：用户体验好，页面切换快，不需要向服务端发起请求，只需要加载静态资源即可。
- 缺点：由于需要加载整个应用的静态资源，所以首屏加载时间会比较长。由于 HTML 中的内容是动态生成的，不利于搜索引擎优化。

**SSR**: 服务器端渲染。网页是通过服务器渲染生成后输出给客户端，客户端拿到的是已经渲染好的 HTML 文件。当用户在应用中跳转时，会产生新的 HTTP 请求，服务端会根据请求的路径重新渲染页面并返回给客户端。

- 优点：首屏加载快，无需等待所有 JavaScript 代码加载完毕。有利于搜索引擎优化，因为搜索引擎可以直接解析服务器返回的 HTML
- 缺点： 服务器压力大；每次页面跳转需要重新加载，用户体验不佳。

## 响应式原理

在描述 Vue 的响应式原理之前，我们首先需要明白什么是响应式。所谓响应式，就是我们希望一个数据变更之后，所有与之有关的地方都能同步这个更改。比如现在页面中渲染了一个元素代表用户的昵称，那么当我们使用 js 修改了这个昵称的时候，我们希望页面中也能同步修改。这就是响应式。那么根据上面的描述中，我们可以知道，实现响应式需要解决三个问题，第一，我们需要知道哪个数据被修改了；第二，我们需要知道与这个数据相关的地方有哪些；第三，我们需要能够通知这些地方，数据发生了变化。

这里就要介绍一个副作用函数的概念，假如说某一个函数的运行会影响其他函数的运行或是改变应用状态，那么我们将其称之为副作用函数。例如有一个函数，它的功能是设置网页 body 内容为用户昵称，这改变了应用的状态，它就是一个副作用函数。我们希望当用户昵称发生改变时，网页能够重新渲染，也就是说这个函数能够重新执行一遍。也就是说，当响应式数据发生变化时，所有与之相关的副作用函数都应该重新执行。

那么问题来了，如何收集与之相关的副作用函数呢？Vue 给出的方案是利用 Proxy 劫持数据的读取操作。当某个函数读取了响应式数据的值时，会被 Proxy 所劫持，在这个过程中我们可以用一个容器来存储这个函数。这就建立了数据与副作用函数之间的依赖关系。

那么当数据发生变化时，如何通知这些副作用函数重新执行呢？这时候需要借助 Proxy 劫持数据的设置操作。当某个代码企图修改响应式数据的值时，会被 Proxy 所劫持，在这个过程中，我们可以从容器中取出与该数据有关的所有副作用函数，并且让他们重新执行一遍。

总而言之，Vue 响应式系统的原理就是利用 Proxy 劫持对数据的读取与设置操作，在读取时收集或者说跟踪所有的副作用函数，在设置时重新执行与之相关的副作用函数。这就是 Vue 响应式系统的基本概念。在具体实现上，还有更多的内容可以探讨。如果你感兴趣我可以继续说一说。

好的，在之前我说到，在跟踪依赖的时候，我们会将副作用函数放入一个容器之中，那么这个容器具体的数据结构是怎样的呢？最外层是一个 WeakMap，键是被代理的对象，值是一个 Map；这个 Map 的键是代理对象的属性，值是一个 Set；这个 Set 存放了与该对象该属性相关的所有副作用函数。

接着我们再来讲讲收集依赖和触发更新的具体过程。我们谈到，利用 Proxy 劫持数据的读取和设置操作。那么到底什么操作算是读取，什么操作算是设置呢？

我们先来看读取操作，常规的读取方式包括:访问属性，会被 get 所拦截；利用 in 操作符判断属性是否存在于对象上，会被 has 所拦截；使用 for...in 遍历对象，会被 ownKeys 所拦截。

再看到设置操作，常规的设置操作包括：通过赋值操作设置属性，会被 set 所拦截；通过 delete 删除属性，会被 deleteProperty 所拦截。

在读取操作的拦截器中我们跟踪副作用函数，在设置操作的拦截器中我们触发副作用函数的重新执行。这就是 Vue 响应式系统的基本原理。

更复杂的内容包括：副作用函数的嵌套，分支切换导致的副作用依赖变化，数组的响应式等等。还有响应式系统的可调度行，computed 于 watch 的实现等等。
